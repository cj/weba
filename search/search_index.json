{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"weba","text":"<p>Weba is a Python library for building web user interfaces using a declarative, component-based approach. It provides a clean API for creating HTML elements and components with proper context management and type safety. The library extends BeautifulSoup's functionality by adding a custom Tag class that supports modern web development patterns, including HTMX integration, class list manipulation, and comment-based selectors. It allows developers to create reusable UI components with proper isolation, supports both synchronous and asynchronous contexts, and handles attribute management (including JSON serialization) elegantly. The library emphasizes type safety and follows clean code practices, making it particularly suitable for building modern web applications in Python with a focus on maintainability and developer experience.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The library supports the following environment variables for configuration:</p> <ul> <li><code>WEBA_LRU_CACHE_SIZE</code>: Controls the maximum size of the LRU cache used for storing parsed HTML templates and file contents. Defaults to 128. Example:</li> </ul> <pre><code>export WEBA_LRU_CACHE_SIZE=256  # Increase cache size to 256 entries\n</code></pre> <ul> <li>Github repository: https://github.com/cj/weba/</li> <li>Documentation https://weba.cj.io/</li> </ul>"},{"location":"modules/","title":"API Reference","text":""},{"location":"modules/#weba.ui.Ui","title":"<code>Ui</code>","text":"<p>A factory class for creating UI elements using BeautifulSoup.</p> Source code in <code>weba/ui.py</code> <pre><code>class Ui:\n    \"\"\"A factory class for creating UI elements using BeautifulSoup.\"\"\"\n\n    _html_parser: ClassVar[str | None] = None\n    _xml_parser: ClassVar[str | None] = None\n\n    @classmethod\n    def get_html_parser(cls) -&gt; str | None:\n        \"\"\"Get the LRU cache size from environment variable.\"\"\"\n        if cls._html_parser is None:\n            cls._html_parser = os.getenv(\"WEBA_HTML_PARSER\", \"html.parser\")\n\n        return cls._html_parser\n\n    @classmethod\n    def get_xml_parser(cls) -&gt; str | None:\n        \"\"\"Get the XML parser from environment variable.\"\"\"\n        if cls._xml_parser is None:\n            cls._xml_parser = os.getenv(\"WEBA_XML_PARSER\", \"xml\")\n\n        return cls._xml_parser\n\n    def text(self, html: str | int | float | Sequence[Any] | None) -&gt; str:\n        \"\"\"Create a raw text node from a string.\n\n        Args:\n            html: Raw text to insert\n\n        Returns:\n            A string containing the text.\n        \"\"\"\n        text = NavigableString(\"\" if html is None else str(html))\n\n        # # Only append to parent if we're creating a new text node\n        # # This prevents double-appending when the text is used in other operations\n        if parent := current_tag_context.get():\n            parent.append(text)\n\n        # Return the raw string only when no parent (for direct usage)\n        return text\n\n    def _handle_lxml_parser(self, html: str, parsed: BeautifulSoupTag) -&gt; Tag | BeautifulSoupTag:\n        stripped_html = html.strip().lower()\n\n        if parsed and parsed.html and all(tag in stripped_html for tag in (\"&lt;body\", \"&lt;head\", \"&lt;html\")):\n            return parsed\n        elif (body := parsed.html) and (stripped_html.startswith(\"&lt;body\") or (body := body.body)):\n            return body\n        elif (head := parsed.html) and (stripped_html.startswith(\"&lt;head\") or (head := head.head)):\n            return head\n\n        return parsed\n\n    def raw(self, html: str | bytes, parser: str | None = None) -&gt; Tag:\n        \"\"\"Create a Tag from a raw HTML string.\n\n        Args:\n            html: Raw HTML string to parse\n\n        Returns:\n            Tag: A new Tag object containing the parsed HTML\n        \"\"\"\n        if isinstance(html, bytes):\n            html = str(from_bytes(html).best())\n\n        parser = parser or (\n            self.__class__.get_xml_parser() if html.startswith(\"&lt;?xml\") else self.__class__.get_html_parser()\n        )\n\n        parsed = BeautifulSoup(html, parser)\n\n        # NOTE: This is to html lxml always wrapping in html &gt; body tags\n        if parser == \"lxml\":\n            parsed = self._handle_lxml_parser(html, parsed)\n\n        # Count root elements\n        root_elements = [child for child in parsed.children if isinstance(child, BeautifulSoupTag)]\n\n        if len(root_elements) == 1:\n            # Single root element - return it directly\n            tag = Tag.from_existing_bs4tag(root_elements[0])\n        else:\n            # Multiple root elements or text only - handle as fragments\n            tag = Tag(name=\"fragment\")\n            tag.string = \"\"\n\n            if root_elements:\n                # Add all root elements\n                for child in root_elements:\n                    tag.append(Tag.from_existing_bs4tag(child))\n            else:\n                # Text only content\n                tag.string = html\n\n            # Ensure fragment tag doesn't render\n            tag.hidden = True\n\n        if parent := current_tag_context.get():\n            parent.append(tag)\n\n        return tag\n\n    def __getattr__(self, tag_name: str) -&gt; Callable[..., Tag]:\n        def create_tag(*args: Any, **kwargs: str | int | float | Sequence[Any]) -&gt; Tag:\n            # Convert underscore attributes to dashes\n            converted_kwargs: dict[str, Any] = {}\n\n            for key, value in kwargs.items():\n                key = key.rstrip(\"_\").replace(\"_\", \"-\")\n\n                if key == \"class\":\n                    if isinstance(value, list | tuple):\n                        value = \" \".join(str(v) for v in value if isinstance(v, str | int | float))\n                else:\n                    # Handle boolean attributes\n                    if isinstance(value, bool) and value:\n                        value = None\n\n                converted_kwargs[key] = value\n\n            # Create a BeautifulSoupTag directly\n            base_tag = BeautifulSoupTag(\n                name=tag_name,\n                attrs=converted_kwargs,\n            )\n\n            # Wrap it into our Tag class\n            tag_obj = Tag.from_existing_bs4tag(base_tag)\n\n            # Handle content\n            if args:\n                arg = args[0]\n                if isinstance(arg, Tag):\n                    tag_obj.append(arg)\n                elif arg is None:\n                    tag_obj.string = \"\"\n                else:\n                    tag_obj.string = str(arg)\n\n            # If there's a current parent, append this tag to it\n            if parent := current_tag_context.get():\n                parent.append(tag_obj)\n\n            return tag_obj\n\n        return create_tag\n</code></pre>"},{"location":"modules/#weba.ui.Ui.get_html_parser","title":"<code>get_html_parser()</code>  <code>classmethod</code>","text":"<p>Get the LRU cache size from environment variable.</p> Source code in <code>weba/ui.py</code> <pre><code>@classmethod\ndef get_html_parser(cls) -&gt; str | None:\n    \"\"\"Get the LRU cache size from environment variable.\"\"\"\n    if cls._html_parser is None:\n        cls._html_parser = os.getenv(\"WEBA_HTML_PARSER\", \"html.parser\")\n\n    return cls._html_parser\n</code></pre>"},{"location":"modules/#weba.ui.Ui.get_xml_parser","title":"<code>get_xml_parser()</code>  <code>classmethod</code>","text":"<p>Get the XML parser from environment variable.</p> Source code in <code>weba/ui.py</code> <pre><code>@classmethod\ndef get_xml_parser(cls) -&gt; str | None:\n    \"\"\"Get the XML parser from environment variable.\"\"\"\n    if cls._xml_parser is None:\n        cls._xml_parser = os.getenv(\"WEBA_XML_PARSER\", \"xml\")\n\n    return cls._xml_parser\n</code></pre>"},{"location":"modules/#weba.ui.Ui.raw","title":"<code>raw(html, parser=None)</code>","text":"<p>Create a Tag from a raw HTML string.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str | bytes</code> <p>Raw HTML string to parse</p> required <p>Returns:</p> Name Type Description <code>Tag</code> <code>Tag</code> <p>A new Tag object containing the parsed HTML</p> Source code in <code>weba/ui.py</code> <pre><code>def raw(self, html: str | bytes, parser: str | None = None) -&gt; Tag:\n    \"\"\"Create a Tag from a raw HTML string.\n\n    Args:\n        html: Raw HTML string to parse\n\n    Returns:\n        Tag: A new Tag object containing the parsed HTML\n    \"\"\"\n    if isinstance(html, bytes):\n        html = str(from_bytes(html).best())\n\n    parser = parser or (\n        self.__class__.get_xml_parser() if html.startswith(\"&lt;?xml\") else self.__class__.get_html_parser()\n    )\n\n    parsed = BeautifulSoup(html, parser)\n\n    # NOTE: This is to html lxml always wrapping in html &gt; body tags\n    if parser == \"lxml\":\n        parsed = self._handle_lxml_parser(html, parsed)\n\n    # Count root elements\n    root_elements = [child for child in parsed.children if isinstance(child, BeautifulSoupTag)]\n\n    if len(root_elements) == 1:\n        # Single root element - return it directly\n        tag = Tag.from_existing_bs4tag(root_elements[0])\n    else:\n        # Multiple root elements or text only - handle as fragments\n        tag = Tag(name=\"fragment\")\n        tag.string = \"\"\n\n        if root_elements:\n            # Add all root elements\n            for child in root_elements:\n                tag.append(Tag.from_existing_bs4tag(child))\n        else:\n            # Text only content\n            tag.string = html\n\n        # Ensure fragment tag doesn't render\n        tag.hidden = True\n\n    if parent := current_tag_context.get():\n        parent.append(tag)\n\n    return tag\n</code></pre>"},{"location":"modules/#weba.ui.Ui.text","title":"<code>text(html)</code>","text":"<p>Create a raw text node from a string.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str | int | float | Sequence[Any] | None</code> <p>Raw text to insert</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string containing the text.</p> Source code in <code>weba/ui.py</code> <pre><code>def text(self, html: str | int | float | Sequence[Any] | None) -&gt; str:\n    \"\"\"Create a raw text node from a string.\n\n    Args:\n        html: Raw text to insert\n\n    Returns:\n        A string containing the text.\n    \"\"\"\n    text = NavigableString(\"\" if html is None else str(html))\n\n    # # Only append to parent if we're creating a new text node\n    # # This prevents double-appending when the text is used in other operations\n    if parent := current_tag_context.get():\n        parent.append(text)\n\n    # Return the raw string only when no parent (for direct usage)\n    return text\n</code></pre>"},{"location":"modules/#weba.tag.Tag","title":"<code>Tag</code>","text":"<p>               Bases: <code>Tag</code></p> Source code in <code>weba/tag.py</code> <pre><code>class Tag(Bs4Tag):\n    @classmethod\n    def from_existing_bs4tag(cls, bs4_tag: Bs4Tag) -&gt; Tag:\n        new_tag = cls(name=bs4_tag.name, attrs=bs4_tag.attrs)\n\n        for c in bs4_tag.contents:\n            if isinstance(c, Bs4Tag):\n                child_tag = cls.from_existing_bs4tag(c)\n                new_tag.append(child_tag)\n            elif isinstance(c, Comment):\n                new_tag.append(Comment(c))\n            else:\n                new_tag.append(NavigableString(str(c)))\n\n        return new_tag\n\n    def __init__(\n        self,\n        parser: BeautifulSoup | None = None,\n        builder: TreeBuilder | None = None,\n        name: str | None = None,\n        namespace: str | None = None,\n        prefix: str | None = None,\n        attrs: dict[str, str] | None = None,\n        parent: Tag | None = None,\n        previous: PageElement | None = None,\n        is_xml: bool | None = None,\n        sourceline: int | None = None,\n        sourcepos: int | None = None,\n        can_be_empty_element: bool | None = None,\n        cdata_list_attributes: list[str] | None = None,\n        preserve_whitespace_tags: list[str] | None = None,\n        interesting_string_types: type[NavigableString] | tuple[type[NavigableString], ...] | None = None,\n        namespaces: dict[str, str] | None = None,\n    ):\n        \"\"\"Basic constructor.\n\n        :param parser: A BeautifulSoup object.\n        :param builder: A TreeBuilder.\n        :param name: The name of the tag.\n        :param namespace: The URI of this Tag's XML namespace, if any.\n        :param prefix: The prefix for this Tag's XML namespace, if any.\n        :param attrs: A dictionary of this Tag's attribute values.\n        :param parent: The PageElement to use as this Tag's parent.\n        :param previous: The PageElement that was parsed immediately before\n            this tag.\n        :param is_xml: If True, this is an XML tag. Otherwise, this is an\n            HTML tag.\n        :param sourceline: The line number where this tag was found in its\n            source document.\n        :param sourcepos: The character position within `sourceline` where this\n            tag was found.\n        :param can_be_empty_element: If True, this tag should be\n            represented as &lt;tag/&gt;. If False, this tag should be represented\n            as &lt;tag&gt;&lt;/tag&gt;.\n        :param cdata_list_attributes: A list of attributes whose values should\n            be treated as CDATA if they ever show up on this tag.\n        :param preserve_whitespace_tags: A list of tag names whose contents\n            should have their whitespace preserved.\n        :param interesting_string_types: This is a NavigableString\n            subclass or a tuple of them. When iterating over this\n            Tag's strings in methods like Tag.strings or Tag.get_text,\n            these are the types of strings that are interesting enough\n            to be considered. The default is to consider\n            NavigableString and CData the only interesting string\n            subtypes.\n        :param namespaces: A dictionary mapping currently active\n            namespace prefixes to URIs. This can be used later to\n            construct CSS selectors.\n        \"\"\"\n        super().__init__(\n            parser=parser,\n            builder=builder,\n            name=name,\n            namespace=namespace,\n            prefix=prefix,\n            attrs=attrs,\n            parent=parent,\n            previous=previous,\n            is_xml=is_xml,\n            sourceline=sourceline,\n            sourcepos=sourcepos,\n            can_be_empty_element=can_be_empty_element,\n            cdata_list_attributes=cdata_list_attributes,\n            preserve_whitespace_tags=preserve_whitespace_tags,\n            interesting_string_types=interesting_string_types,\n            namespaces=namespaces,\n        )\n        self._token: Token[Tag | None] | None = None\n\n    def __enter__(self):\n        self._token = current_tag_context.set(self)  # pyright: ignore[reportArgumentType, reportAttributeAccessIssue]\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        current_tag_context.reset(self._token)  # pyright: ignore[reportArgumentType]\n\n    @overload  # pragma: no cover # NOTE: We have tests that cover this case\n    def __getitem__(self, key: Literal[\"class\"]) -&gt; list[str]:\n        \"\"\"Get attribute value, ensuring class returns as list.\"\"\"\n        ...\n\n    @overload  # pragma: no cover # NOTE: We have tests that cover this case\n    def __getitem__(self, key: str) -&gt; str | list[str]:\n        \"\"\"Get attribute value for non-class attributes.\"\"\"\n        ...\n\n    def __getitem__(self, key: str) -&gt; str | list[str]:\n        if key == \"class\":\n            current_value = self.attrs.get(\"class\")\n\n            if isinstance(current_value, str):\n                current_value = current_value.split()\n            elif not isinstance(current_value, list):\n                current_value = []\n            else:\n                current_value = current_value.copy()  # pyright: ignore[reportUnknownVariableType]\n\n            self.attrs[\"class\"] = current_value\n\n            return current_value  # pyright: ignore[reportUnknownVariableType]\n\n        value = self.attrs[key]\n\n        return json.dumps(value) if isinstance(value, dict | list) else value\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Set an attribute value, handling boolean attributes correctly.\"\"\"\n        if isinstance(value, bool):\n            if value:\n                # For True, set attribute with empty string value\n                self.attrs[key] = None\n            else:\n                # For False, remove the attribute\n                self.attrs.pop(key, None)\n        else:\n            # Handle non-boolean values normally\n            self.attrs[key] = value\n\n    # def comment(self, selector: str) -&gt; list[Tag | NavigableString | None]:\n    def comment(self, selector: str) -&gt; list[Tag | None]:\n        \"\"\"Find all tags or text nodes that follow comments matching the given selector.\n\n        This method searches for HTML comments containing the selector text and returns\n        the elements that immediately follow those comments. It can return both HTML\n        elements and text nodes.\n\n        Args:\n            selector: The comment text to search for (e.g., \"#button\" or \".card\")\n\n        Returns:\n            A list of Tag or NavigableString objects that immediately follow matching comments.\n            For text nodes, returns them as `NavigableString`.\n            Returns an empty list if no matches are found.\n        \"\"\"\n        # results: list[Tag | NavigableString | None] = []\n        results: list[Tag | None] = []\n\n        # Find all comment nodes matching the selector exactly\n        comments = self.find_all(string=lambda text: isinstance(text, str) and text.strip() == selector.strip())\n\n        for comment in comments:\n            # Get the next sibling of the comment\n            next_node = comment.next_sibling\n\n            # Skip empty text nodes\n            while next_node and isinstance(next_node, NavigableString) and not next_node.strip():\n                next_node = next_node.next_sibling\n\n            if isinstance(next_node, Tag):\n                # Convert to our Tag but preserve comments\n                results.append(next_node)\n            # elif isinstance(next_node, NavigableString) and (text := next_node.strip()):\n            #     # Return the NavigableString as-is\n            #     results.append(NavigableString(text))\n\n        return results\n\n    # def comment_one(self, selector: str) -&gt; Tag | NavigableString | None:\n    def comment_one(self, selector: str) -&gt; Tag | None:\n        \"\"\"Find the first tag or text node that follows a comment matching the given selector.\n\n        This method searches for the first HTML comment containing the selector text and returns\n        the element that immediately follows it. It can return both HTML elements and text nodes.\n        Returns None if no match is found.\n\n        Args:\n            selector: The comment text to search for (e.g., \"#button\" or \".card\")\n\n        Returns:\n            A Tag object if the next element is an HTML tag, or a NavigableString if it's a text node.\n            Returns None if no match is found.\n        \"\"\"\n        # Find all comment nodes matching the selector exactly\n        comments = self.find_all(string=lambda text: isinstance(text, str) and text.strip() == selector.strip())\n\n        for comment in comments:\n            # Get the next sibling of the comment\n            next_node = comment.next_sibling\n            while next_node:\n                if isinstance(next_node, Tag):\n                    # Return the tag without removing comments\n                    return next_node\n\n                # if isinstance(next_node, NavigableString) and (text := next_node.strip()):\n                #     # Return NavigableString directly for consistency\n                #     return NavigableString(text)\n\n                next_node = next_node.next_sibling\n\n        return None\n\n    def __iter__(self) -&gt; Iterator[PageElement]:\n        \"\"\"Iterate over children, creating a static list to prevent modification during iteration.\"\"\"\n        return iter(list(self.contents))\n\n    def __copy__(self) -&gt; Tag:\n        return Tag.from_existing_bs4tag(self)\n\n    def copy(self) -&gt; Tag:\n        \"\"\"Create a copy of this tag.\n\n        Returns:\n            A new Tag instance that is a copy of this tag\n        \"\"\"\n        return self.__copy__()\n</code></pre>"},{"location":"modules/#weba.tag.Tag.__init__","title":"<code>__init__(parser=None, builder=None, name=None, namespace=None, prefix=None, attrs=None, parent=None, previous=None, is_xml=None, sourceline=None, sourcepos=None, can_be_empty_element=None, cdata_list_attributes=None, preserve_whitespace_tags=None, interesting_string_types=None, namespaces=None)</code>","text":"<p>Basic constructor.</p> <p>:param parser: A BeautifulSoup object. :param builder: A TreeBuilder. :param name: The name of the tag. :param namespace: The URI of this Tag's XML namespace, if any. :param prefix: The prefix for this Tag's XML namespace, if any. :param attrs: A dictionary of this Tag's attribute values. :param parent: The PageElement to use as this Tag's parent. :param previous: The PageElement that was parsed immediately before     this tag. :param is_xml: If True, this is an XML tag. Otherwise, this is an     HTML tag. :param sourceline: The line number where this tag was found in its     source document. :param sourcepos: The character position within <code>sourceline</code> where this     tag was found. :param can_be_empty_element: If True, this tag should be     represented as . If False, this tag should be represented     as . :param cdata_list_attributes: A list of attributes whose values should     be treated as CDATA if they ever show up on this tag. :param preserve_whitespace_tags: A list of tag names whose contents     should have their whitespace preserved. :param interesting_string_types: This is a NavigableString     subclass or a tuple of them. When iterating over this     Tag's strings in methods like Tag.strings or Tag.get_text,     these are the types of strings that are interesting enough     to be considered. The default is to consider     NavigableString and CData the only interesting string     subtypes. :param namespaces: A dictionary mapping currently active     namespace prefixes to URIs. This can be used later to     construct CSS selectors.</p> Source code in <code>weba/tag.py</code> <pre><code>def __init__(\n    self,\n    parser: BeautifulSoup | None = None,\n    builder: TreeBuilder | None = None,\n    name: str | None = None,\n    namespace: str | None = None,\n    prefix: str | None = None,\n    attrs: dict[str, str] | None = None,\n    parent: Tag | None = None,\n    previous: PageElement | None = None,\n    is_xml: bool | None = None,\n    sourceline: int | None = None,\n    sourcepos: int | None = None,\n    can_be_empty_element: bool | None = None,\n    cdata_list_attributes: list[str] | None = None,\n    preserve_whitespace_tags: list[str] | None = None,\n    interesting_string_types: type[NavigableString] | tuple[type[NavigableString], ...] | None = None,\n    namespaces: dict[str, str] | None = None,\n):\n    \"\"\"Basic constructor.\n\n    :param parser: A BeautifulSoup object.\n    :param builder: A TreeBuilder.\n    :param name: The name of the tag.\n    :param namespace: The URI of this Tag's XML namespace, if any.\n    :param prefix: The prefix for this Tag's XML namespace, if any.\n    :param attrs: A dictionary of this Tag's attribute values.\n    :param parent: The PageElement to use as this Tag's parent.\n    :param previous: The PageElement that was parsed immediately before\n        this tag.\n    :param is_xml: If True, this is an XML tag. Otherwise, this is an\n        HTML tag.\n    :param sourceline: The line number where this tag was found in its\n        source document.\n    :param sourcepos: The character position within `sourceline` where this\n        tag was found.\n    :param can_be_empty_element: If True, this tag should be\n        represented as &lt;tag/&gt;. If False, this tag should be represented\n        as &lt;tag&gt;&lt;/tag&gt;.\n    :param cdata_list_attributes: A list of attributes whose values should\n        be treated as CDATA if they ever show up on this tag.\n    :param preserve_whitespace_tags: A list of tag names whose contents\n        should have their whitespace preserved.\n    :param interesting_string_types: This is a NavigableString\n        subclass or a tuple of them. When iterating over this\n        Tag's strings in methods like Tag.strings or Tag.get_text,\n        these are the types of strings that are interesting enough\n        to be considered. The default is to consider\n        NavigableString and CData the only interesting string\n        subtypes.\n    :param namespaces: A dictionary mapping currently active\n        namespace prefixes to URIs. This can be used later to\n        construct CSS selectors.\n    \"\"\"\n    super().__init__(\n        parser=parser,\n        builder=builder,\n        name=name,\n        namespace=namespace,\n        prefix=prefix,\n        attrs=attrs,\n        parent=parent,\n        previous=previous,\n        is_xml=is_xml,\n        sourceline=sourceline,\n        sourcepos=sourcepos,\n        can_be_empty_element=can_be_empty_element,\n        cdata_list_attributes=cdata_list_attributes,\n        preserve_whitespace_tags=preserve_whitespace_tags,\n        interesting_string_types=interesting_string_types,\n        namespaces=namespaces,\n    )\n    self._token: Token[Tag | None] | None = None\n</code></pre>"},{"location":"modules/#weba.tag.Tag.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over children, creating a static list to prevent modification during iteration.</p> Source code in <code>weba/tag.py</code> <pre><code>def __iter__(self) -&gt; Iterator[PageElement]:\n    \"\"\"Iterate over children, creating a static list to prevent modification during iteration.\"\"\"\n    return iter(list(self.contents))\n</code></pre>"},{"location":"modules/#weba.tag.Tag.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an attribute value, handling boolean attributes correctly.</p> Source code in <code>weba/tag.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute value, handling boolean attributes correctly.\"\"\"\n    if isinstance(value, bool):\n        if value:\n            # For True, set attribute with empty string value\n            self.attrs[key] = None\n        else:\n            # For False, remove the attribute\n            self.attrs.pop(key, None)\n    else:\n        # Handle non-boolean values normally\n        self.attrs[key] = value\n</code></pre>"},{"location":"modules/#weba.tag.Tag.comment","title":"<code>comment(selector)</code>","text":"<p>Find all tags or text nodes that follow comments matching the given selector.</p> <p>This method searches for HTML comments containing the selector text and returns the elements that immediately follow those comments. It can return both HTML elements and text nodes.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>The comment text to search for (e.g., \"#button\" or \".card\")</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>A list of Tag or NavigableString objects that immediately follow matching comments.</p> <code>Comment</code> <p>For text nodes, returns them as <code>NavigableString</code>.</p> <code>Comment</code> <p>Returns an empty list if no matches are found.</p> Source code in <code>weba/tag.py</code> <pre><code>def comment(self, selector: str) -&gt; list[Tag | None]:\n    \"\"\"Find all tags or text nodes that follow comments matching the given selector.\n\n    This method searches for HTML comments containing the selector text and returns\n    the elements that immediately follow those comments. It can return both HTML\n    elements and text nodes.\n\n    Args:\n        selector: The comment text to search for (e.g., \"#button\" or \".card\")\n\n    Returns:\n        A list of Tag or NavigableString objects that immediately follow matching comments.\n        For text nodes, returns them as `NavigableString`.\n        Returns an empty list if no matches are found.\n    \"\"\"\n    # results: list[Tag | NavigableString | None] = []\n    results: list[Tag | None] = []\n\n    # Find all comment nodes matching the selector exactly\n    comments = self.find_all(string=lambda text: isinstance(text, str) and text.strip() == selector.strip())\n\n    for comment in comments:\n        # Get the next sibling of the comment\n        next_node = comment.next_sibling\n\n        # Skip empty text nodes\n        while next_node and isinstance(next_node, NavigableString) and not next_node.strip():\n            next_node = next_node.next_sibling\n\n        if isinstance(next_node, Tag):\n            # Convert to our Tag but preserve comments\n            results.append(next_node)\n        # elif isinstance(next_node, NavigableString) and (text := next_node.strip()):\n        #     # Return the NavigableString as-is\n        #     results.append(NavigableString(text))\n\n    return results\n</code></pre>"},{"location":"modules/#weba.tag.Tag.comment_one","title":"<code>comment_one(selector)</code>","text":"<p>Find the first tag or text node that follows a comment matching the given selector.</p> <p>This method searches for the first HTML comment containing the selector text and returns the element that immediately follows it. It can return both HTML elements and text nodes. Returns None if no match is found.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>The comment text to search for (e.g., \"#button\" or \".card\")</p> required <p>Returns:</p> Type Description <code>Tag | None</code> <p>A Tag object if the next element is an HTML tag, or a NavigableString if it's a text node.</p> <code>Tag | None</code> <p>Returns None if no match is found.</p> Source code in <code>weba/tag.py</code> <pre><code>def comment_one(self, selector: str) -&gt; Tag | None:\n    \"\"\"Find the first tag or text node that follows a comment matching the given selector.\n\n    This method searches for the first HTML comment containing the selector text and returns\n    the element that immediately follows it. It can return both HTML elements and text nodes.\n    Returns None if no match is found.\n\n    Args:\n        selector: The comment text to search for (e.g., \"#button\" or \".card\")\n\n    Returns:\n        A Tag object if the next element is an HTML tag, or a NavigableString if it's a text node.\n        Returns None if no match is found.\n    \"\"\"\n    # Find all comment nodes matching the selector exactly\n    comments = self.find_all(string=lambda text: isinstance(text, str) and text.strip() == selector.strip())\n\n    for comment in comments:\n        # Get the next sibling of the comment\n        next_node = comment.next_sibling\n        while next_node:\n            if isinstance(next_node, Tag):\n                # Return the tag without removing comments\n                return next_node\n\n            # if isinstance(next_node, NavigableString) and (text := next_node.strip()):\n            #     # Return NavigableString directly for consistency\n            #     return NavigableString(text)\n\n            next_node = next_node.next_sibling\n\n    return None\n</code></pre>"},{"location":"modules/#weba.tag.Tag.copy","title":"<code>copy()</code>","text":"<p>Create a copy of this tag.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Tag instance that is a copy of this tag</p> Source code in <code>weba/tag.py</code> <pre><code>def copy(self) -&gt; Tag:\n    \"\"\"Create a copy of this tag.\n\n    Returns:\n        A new Tag instance that is a copy of this tag\n    \"\"\"\n    return self.__copy__()\n</code></pre>"},{"location":"examples/component/","title":"Component Examples","text":""},{"location":"examples/component/#basic-component","title":"Basic Component","text":"<p>Create a simple button component:</p> <pre><code>from weba import Component, ui\n\nclass Button(Component):\n    src = \"&lt;button&gt;Example&lt;/button&gt;\"\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    def render(self):\n        self.string = self.msg\n\n# Usage\nwith ui.div() as container:\n    Button(\"Click me\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;button&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#replace-root-tag","title":"Replace Root Tag","text":"<p>Components can replace their root tag while preserving contents:</p> <pre><code>class RootComponent(Component):\n    src = \"&lt;div&gt;Content &lt;span&gt;here&lt;/span&gt;&lt;/div&gt;\"\n\n    def render(self):\n        self.replace_root_tag(ui.section(class_=\"container\"))\n\n# Usage\ncomponent = RootComponent()\nprint(component)\n</code></pre> <p>Output:</p> <pre><code>&lt;section class=\"container\"&gt;Content &lt;span&gt;here&lt;/span&gt;&lt;/section&gt;\n</code></pre>"},{"location":"examples/component/#replace-root-tag-using-selector","title":"Replace Root Tag Using Selector","text":"<p>Components can also replace their root tag based on a selector:</p> <pre><code>class RootTagComponent(Component):\n    src = \"&lt;div&gt;Content &lt;span&gt;here&lt;/span&gt;&lt;section class='container'&gt;Content &lt;span&gt;here&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;\"\n\n    @tag(\"section\", root_tag=True)\n    def section(self):\n        pass\n\n# Usage\ncomponent = RootTagComponent()\nprint(component)\n</code></pre> <p>Output:</p> <pre><code>&lt;section class=\"container\"&gt;Content &lt;span&gt;here&lt;/span&gt;&lt;/section&gt;\n</code></pre>"},{"location":"examples/component/#using-tag-decorators","title":"Using Tag Decorators","text":"<p>Components with tag decorators for more control:</p> <pre><code>class Button(Component):\n    src = \"&lt;div&gt;&lt;button class='btn'&gt;Example&lt;/button&gt;&lt;/div&gt;\"\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    @tag(\"button\")\n    def button_tag(self, t: Tag):\n        t.string = self.msg\n\n# Usage\nwith ui.div() as container:\n    Button(\"Submit\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;div&gt;\n    &lt;button class=\"btn\"&gt;Submit&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#comment-selectors","title":"Comment Selectors","text":"<p>Use HTML comments as selectors:</p> <pre><code>class Button(Component):\n    src = \"\"\"&lt;div&gt;&lt;!-- #button --&gt;&lt;button&gt;Example&lt;/button&gt;&lt;/div&gt;\"\"\"\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    @tag(\"&lt;!-- #button --&gt;\")\n    def button_tag(self, t: Tag):\n        t.string = self.msg\n\n# Usage\nwith ui.div() as container:\n    Button(\"Delete\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;div&gt;\n    &lt;!-- #button --&gt;\n    &lt;button&gt;Delete&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#async-components","title":"Async Components","text":"<p>Create components with async rendering:</p> <pre><code>import asyncio\n\nclass AsyncButton(Component):\n    src = \"&lt;button&gt;&lt;/button&gt;\"\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    async def render(self):\n        await asyncio.sleep(0.01)  # Simulate async operation\n        self.string = self.msg\n\n# Usage\nasync def main():\n    with ui.div() as container:\n        await AsyncButton(\"Async Click Me\")\n        await AsyncButton(\"Another Button\")\n\n    print(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;button&gt;Async Click Me&lt;/button&gt;\n  &lt;button&gt;Another Button&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#extract-and-clear-tags","title":"Extract and Clear Tags","text":"<p>Manipulate component structure with extract and clear options:</p> <pre><code>class Button(Component):\n    src = \"&lt;div&gt;&lt;button class='btn'&gt;Example&lt;/button&gt;&lt;/div&gt;\"\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    @tag(\"button\", extract=True)\n    def button_tag(self, t: Tag):\n        t.string = self.msg\n\n    def add_button(self):\n        \"\"\"Add a button to the component.\"\"\"\n        self.append(self.button_tag)\n\n# Usage\nbutton = Button(\"Extracted\")\nprint(button)\n\nbutton.add_button()\nprint(button)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n&lt;div&gt;\n  &lt;button class=\"btn\"&gt;Extracted&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#dynamic-list-component","title":"Dynamic List Component","text":"<p>Create a component that dynamically generates list items:</p> <pre><code>class ListComponent(Component):\n    src = \"\"\"\n    &lt;ul&gt;\n        &lt;li&gt;Item 1&lt;/li&gt;\n        &lt;li&gt;Item 2&lt;/li&gt;\n        &lt;li&gt;Item 3&lt;/li&gt;\n    &lt;/ul&gt;\n    \"\"\"\n\n    def __init__(self, list_items: list[str]):\n        self.list_items = list_items\n\n    def render(self):\n        for item in self.list_items:\n            list_item = self.list_item_tag.copy()\n            list_item.string = item\n            self.list_tag.append(list_item)\n\n    @tag(\"li\", extract=True)\n    def list_item_tag(self):\n        pass\n\n    @tag(clear=True)\n    def list_tag(self):\n        pass\n\n# Usage\nlist_comp = ListComponent([\"one\", \"two\", \"three\"])\nprint(list_comp)\n</code></pre> <p>Output:</p> <pre><code>&lt;ul&gt;\n  &lt;li&gt;one&lt;/li&gt;\n  &lt;li&gt;two&lt;/li&gt;\n  &lt;li&gt;three&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"},{"location":"examples/component/#async-before-render","title":"Async Before Render","text":"<p>Components can perform async operations before rendering:</p> <pre><code>import asyncio\n\nclass UserProfile(Component):\n    src = \"&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;div class='content'&gt;&lt;/div&gt;&lt;/div&gt;\"\n\n    def __init__(self, user_id: str):\n        self.user_id = user_id\n        self.user_data = None\n\n    async def before_render(self):\n        # Simulate fetching user data (this would be some async data request)\n        await asyncio.sleep(0.1)\n        self.user_data = {\n            \"name\": \"Alice Smith\",\n            \"bio\": \"Python Developer\"\n        }\n\n    def render(self):\n        self.select_one(\"h2\").string = self.user_data[\"name\"]\n\n        with self.select_one(\".content\"):\n            ui.p(self.user_data[\"bio\"])\n\n# Usage\nasync def main():\n    profile = await UserProfile(\"123\")\n    print(str(profile))\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;Alice Smith&lt;/h2&gt;\n  &lt;div class=\"content\"&gt;\n    &lt;p&gt;Python Developer&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#component-from-file","title":"Component from File","text":"<p>Load component HTML from external file:</p> <pre><code>class Button(Component):\n    src = \"./button.html\"  # Contents: &lt;button&gt;Test Button&lt;/button&gt;\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    def render(self):\n        self.string = self.msg\n\n# Usage\nwith ui.div() as container:\n    Button(\"Save\")\n    Button(\"Edit\")\n    Button(\"Delete\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;button&gt;Save&lt;/button&gt;\n  &lt;button&gt;Edit&lt;/button&gt;\n  &lt;button&gt;Delete&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#using-no_tag_context","title":"Using no_tag_context","text":"<p>The <code>no_tag_context</code> context manager temporarily disables tag context tracking:</p> <pre><code>from weba import Component, ui, no_tag_context\n\nclass NestedComponent(Component):\n    src = \"&lt;div&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;\"\n\n    def render(self):\n        # Normal context - appends to current component\n        with self.select_one(\"ul\"):\n            ui.li(\"First item\")\n\n        # Disable context tracking - creates standalone tags\n        with no_tag_context():\n            standalone_li = ui.li(\"Standalone item\")\n            # Manually append where needed\n            self.select_one(\"ul\").append(standalone_li)\n\n# Usage\nwith ui.div() as container:\n    NestedComponent()\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li&gt;First item&lt;/li&gt;\n      &lt;li&gt;Standalone item&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#component-lifecycle-hooks","title":"Component Lifecycle Hooks","text":"<p>Components support <code>before_render</code>, <code>render</code>, and <code>after_render</code> hooks:</p> <pre><code>class UserProfile(Component):\n    src = \"&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;\"\n\n    def __init__(self):\n        self.steps = []\n\n    def before_render(self):\n        self.steps.append(\"before\")\n        self.name = \"Alice Smith\"\n\n    def render(self):\n        self.steps.append(\"render\")\n        self.select_one(\"h2\").string = self.name\n        self.select_one(\"p\").string = \"Profile loaded\"\n\n    def after_render(self):\n        self.steps.append(\"after\")\n        self.select_one(\"p\").string += \" \u2713\"\n\n# Usage outside context manager - all hooks run immediately\nprofile = UserProfile()\nassert profile.steps == [\"before\", \"render\", \"after\"]\nprint(profile)  # &lt;div&gt;&lt;h2&gt;Alice Smith&lt;/h2&gt;&lt;p&gt;Profile loaded \u2713&lt;/p&gt;&lt;/div&gt;\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;Alice Smith&lt;/h2&gt;\n  &lt;p&gt;Profile loaded \u2713&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#async-component-lifecycle-hooks","title":"Async Component Lifecycle Hooks","text":"<p>Components can use async hooks for data loading and rendering:</p> <pre><code>class AsyncProfile(Component):\n    src = \"&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;\"\n\n    async def before_render(self):\n        # Simulate fetching user data\n        await asyncio.sleep(0.1)\n        self.name = \"Bob Jones\"\n\n    async def render(self):\n        self.select_one(\"h2\").string = self.name\n\n    async def after_render(self):\n        self.select_one(\"p\").string = \"Async loaded\"\n\n# Usage with async context manager\nasync with AsyncProfile() as profile:\n    # before_render and render have run\n    profile.append(ui.span(\"Extra content\"))\n    # after_render runs on context exit\n\nprint(profile)  # &lt;div&gt;&lt;h2&gt;Bob Jones&lt;/h2&gt;&lt;p&gt;Async loaded&lt;/p&gt;&lt;span&gt;Extra content&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;Bob Jones&lt;/h2&gt;\n  &lt;p&gt;Async loaded&lt;/p&gt;\n  &lt;span&gt;Extra content&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#or-without-context-manager","title":"Or without context manager","text":"<pre><code>profile = await AsyncProfile()\nprint(profile)  # &lt;div&gt;&lt;h2&gt;Bob Jones&lt;/h2&gt;&lt;p&gt;Async loaded&lt;/p&gt;&lt;/div&gt;\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;Bob Jones&lt;/h2&gt;\n  &lt;p&gt;Async loaded&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/component/#select-root-tag-from-source","title":"Select Root Tag from Source","text":"<p>Components can select a new root tag from their source HTML using <code>src_root_tag</code>:</p> <pre><code>class CardComponent(Component):\n    src = \"\"\"\n    &lt;div class=\"wrapper\"&gt;\n        &lt;section class=\"card\"&gt;\n            &lt;h2&gt;Card Title&lt;/h2&gt;\n            &lt;p&gt;Card content goes here&lt;/p&gt;\n        &lt;/section&gt;\n        &lt;div class=\"footer\"&gt;Footer content&lt;/div&gt;\n    &lt;/div&gt;\n    \"\"\"\n    # Select the card section as the root, discarding wrapper and footer\n    src_root_tag = \"section.card\"\n\n# Usage\ncard = CardComponent()\nprint(card)\n</code></pre> <p>Output:</p> <pre><code>&lt;section class=\"card\"&gt;\n  &lt;h2&gt;Card Title&lt;/h2&gt;\n  &lt;p&gt;Card content goes here&lt;/p&gt;\n&lt;/section&gt;\n</code></pre> <p>This is equivalent to using <code>@tag(\"section.card\", root_tag=True)</code> but requires less code.</p>"},{"location":"examples/component/#replace-component-content","title":"Replace Component Content","text":"<p>Components can replace their content using tag assignment:</p> <pre><code>class HelloComponent(Component):\n    src = \"./layout.html\"  # A layout with &lt;body&gt;&lt;main&gt;&lt;/main&gt;&lt;/body&gt;\n\n    @tag(\"body &gt; main\")\n    def main(self):\n        pass\n\n    def render(self):\n        self.main = ui.raw(\"&lt;main&gt;Hello&lt;/main&gt;\")\n\n# Usage with context manager\nwith HelloComponent() as html:\n    html.main.append(ui.text(\", World!\"))\n\nprint(html)  # Contains: &lt;main&gt;Hello, World!&lt;/main&gt;\n</code></pre> <p>Output:</p> <pre><code>&lt;main&gt;Hello, World!&lt;/main&gt;\n</code></pre> <p>This example shows how to:</p> <ol> <li>Select a section of the component using CSS selectors</li> <li>Replace its content by assigning a new tag</li> <li>Modify the replaced content within the context manager</li> </ol>"},{"location":"examples/ui/","title":"Examples","text":""},{"location":"examples/ui/#basic-usage","title":"Basic Usage","text":"<p>Create a simple \"Hello World\" page:</p> <pre><code>from weba import ui\n\nwith ui.div() as container:\n    ui.h1(\"Hello, World!\")\n    ui.p(\"Welcome to weba!\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h1&gt;Hello, World!&lt;/h1&gt;\n  &lt;p&gt;Welcome to weba!&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/ui/#working-with-attributes","title":"Working with Attributes","text":"<p>Add classes and other attributes to elements:</p> <pre><code>with ui.div(class_=[\"container\", \"mx-auto\", \"p-4\"]) as container:\n    ui.h1(\"Styled Heading\", class_=\"text-2xl font-bold\")\n    ui.p(\"Some content\", class_=\"mt-2\", data_testid=\"content\")\n\nprint(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div class=\"container mx-auto p-4\"&gt;\n  &lt;h1 class=\"text-2xl font-bold\"&gt;Styled Heading&lt;/h1&gt;\n  &lt;p class=\"mt-2\" data-testid=\"content\"&gt;Some content&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/ui/#nested-elements","title":"Nested Elements","text":"<p>Create complex nested structures:</p> <pre><code>with ui.div(class_=\"card\") as card:\n    with ui.div(class_=\"card-header\"):\n        ui.h2(\"Card Title\")\n    with ui.div(class_=\"card-body\"):\n        ui.p(\"Card content goes here\")\n        with ui.ul(class_=\"list\"):\n            ui.li(\"Item 1\")\n            ui.li(\"Item 2\")\n    with ui.div(class_=\"card-footer\"):\n        ui.button(\"Click me!\", class_=\"btn\")\n\nprint(card)\n</code></pre> <p>Output:</p> <pre><code>&lt;div class=\"card\"&gt;\n  &lt;div class=\"card-header\"&gt;\n    &lt;h2&gt;Card Title&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;div class=\"card-body\"&gt;\n    &lt;p&gt;Card content goes here&lt;/p&gt;\n    &lt;ul class=\"list\"&gt;\n      &lt;li&gt;Item 1&lt;/li&gt;\n      &lt;li&gt;Item 2&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;div class=\"card-footer\"&gt;\n    &lt;button class=\"btn\"&gt;Click me!&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/ui/#dynamic-content","title":"Dynamic Content","text":"<p>Handle different types of values:</p> <pre><code>from datetime import datetime\n\nwith ui.div() as content:\n    ui.p(42)  # Numbers\n    ui.p(3.14159)  # Floats\n    ui.p(True)  # Booleans\n    ui.p(datetime.now())  # DateTime objects\n\nprint(content)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;p&gt;42&lt;/p&gt;\n  &lt;p&gt;3.14159&lt;/p&gt;\n  &lt;p&gt;True&lt;/p&gt;\n  &lt;p&gt;2024-02-20 10:30:45&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/ui/#htmx-integration","title":"HTMX Integration","text":"<p>Use HTMX attributes for dynamic behavior:</p> <pre><code>with ui.form() as form:\n    ui.input_(\n        type=\"text\",\n        name=\"search\",\n        hx_post=\"/search\",\n        hx_trigger=\"keyup changed delay:500ms\",\n        hx_target=\"#results\"\n    )\n    with ui.div(id=\"results\"):\n        ui.p(\"Results will appear here...\")\n\nprint(form)\n</code></pre> <p>Output:</p> <pre><code>&lt;form&gt;\n  &lt;input type=\"text\" name=\"search\" hx-post=\"/search\" hx-trigger=\"keyup changed delay:500ms\" hx-target=\"#results\" /&gt;\n  &lt;div id=\"results\"&gt;\n    &lt;p&gt;Results will appear here...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"examples/ui/#class-manipulation","title":"Class Manipulation","text":"<p>Dynamically modify classes:</p> <pre><code>button = ui.button(\"Toggle\")\nbutton[\"class\"].append(\"active\")\nbutton[\"class\"].append(\"highlight\")\nprint(button)\n</code></pre> <p>Output:</p> <pre><code>&lt;button class=\"active highlight\"&gt;Toggle&lt;/button&gt;\n</code></pre>"},{"location":"examples/ui/#tag-manipulation","title":"Tag Manipulation","text":"<p>Extract, replace and modify tags:</p> <pre><code># Extract a tag from its parent\nwith ui.div() as container:\n    child = ui.p(\"Test\")\n    extracted = child.extract()  # Removes from parent but keeps the tag\n    print(extracted.parent)  # None\n    print(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n</code></pre> <pre><code># Replace tags\nwith ui.div() as container:\n    original = ui.p(\"Original\")\n    ui.span(\"Other\")\n\n    # Replace with a single tag\n    original.replace_with(ui.h2(\"New\"))\n    print(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;New&lt;/h2&gt;\n  &lt;span&gt;Other&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <pre><code># Replace with multiple tags\nwith ui.div() as container:\n    original = ui.p(\"Original\")\n    original.replace_with(\n        ui.h2(\"First\"),\n        ui.h3(\"Second\")\n    )\n    print(container)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n  &lt;h2&gt;First&lt;/h2&gt;\n  &lt;h3&gt;Second&lt;/h3&gt;\n&lt;/div&gt;\n</code></pre> <pre><code># Set tag attributes directly\nbutton = ui.button(\"Click me\")\nbutton.string = \"Submit\"  # Change content\nbutton.name = \"input\"    # Change tag type\nbutton.attrs[\"class\"] = [\"primary\", \"large\"]  # Set multiple classes\nbutton.attrs[\"data-test\"] = \"value\"  # Set custom attribute\n\nprint(button)\n</code></pre> <p>Output:</p> <pre><code>&lt;input\n    class=\"primary large\"\n    data-test=\"value\"\n&gt;Submit&lt;/input&gt;\n</code></pre>"},{"location":"examples/ui/#raw-html-integration","title":"Raw HTML Integration","text":"<p>Parse and integrate raw HTML strings:</p> <pre><code># Basic raw HTML\ntag = ui.raw(\"&lt;div&gt;Hello World&lt;/div&gt;\")\ntag[\"class\"].append(\"raw\")\nprint(tag)  # &lt;div class=\"raw\"&gt;Hello World&lt;/div&gt;\n\n# Complex nested HTML\nhtml = \"\"\"\n&lt;article class=\"post\"&gt;\n    &lt;h2&gt;Blog Post&lt;/h2&gt;\n    &lt;div class=\"content\"&gt;\n        &lt;p&gt;First paragraph&lt;/p&gt;\n        &lt;p&gt;Second paragraph&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/article&gt;\n\"\"\"\ncontent = ui.raw(html)\n\n# Use raw HTML within context managers\nwith ui.div(class_=\"wrapper\") as container:\n    ui.raw(\"&lt;header&gt;Page Title&lt;/header&gt;\")\n    with ui.main():\n        ui.raw(\"&lt;p&gt;Some content&lt;/p&gt;\")\n    ui.raw(\"&lt;footer&gt;Page Footer&lt;/footer&gt;\")\n</code></pre>"},{"location":"examples/ui/#text-node-handling","title":"Text Node Handling","text":"<p>Create and manipulate text nodes:</p> <pre><code># Basic text nodes\ntext = ui.text(\"Hello World\")\nprint(text)  # Hello World\n\n# Different content types\nui.text(42)  # \"42\"\nui.text(3.14)  # \"3.14\"\nui.text(True)  # \"True\"\nui.text(None)  # \"None\"\n\n# Text nodes in context\nwith ui.div() as container:\n    ui.text(\"First \")\n    with ui.strong():\n        ui.text(\"important\")\n    ui.text(\" last\")\n\nprint(container)  # &lt;div&gt;First &lt;strong&gt;important&lt;/strong&gt; last&lt;/div&gt;\n\n# Complex text layout\n\nwith ui.article() as article:\n    ui.text(\"Start of article. \")\n    with ui.em():\n        ui.text(\"Emphasized text. \")\n    ui.text(\"Regular text. \")\n    with ui.strong():\n        ui.text(\"Strong text.\")\n    ui.text(\" End of article.\")\n\nprint(article)\n# &lt;article&gt;Start of article. &lt;em&gt;Emphasized text. &lt;/em&gt;Regular text. &lt;strong&gt;Strong text.&lt;/strong&gt;\n# End of article.&lt;/article&gt;\n</code></pre>"},{"location":"examples/ui/#json-attributes","title":"JSON Attributes","text":"<p>Handle complex data structures as HTML attributes:</p> <pre><code>import json\n\n# Dictionary attributes\ndata = {\"name\": \"John\", \"age\": 30}\nwith ui.div(data_user=data) as div:\n    print(div)  # &lt;div data-user='{\"name\": \"John\", \"age\": 30}'&gt;&lt;/div&gt;\n\n# Array attributes\nitems = [\"apple\", \"banana\", \"orange\"]\nwith ui.div(data_items=items) as div:\n    print(div)  # &lt;div data-items='[\"apple\", \"banana\", \"orange\"]'&gt;&lt;/div&gt;\n\n# Nested structures\ncomplex_data = {\n    \"user\": {\"name\": \"John\", \"age\": 30},\n    \"items\": [\"apple\", \"banana\"],\n    \"active\": True\n}\nwith ui.div(data_complex=complex_data) as div:\n    print(div)\n    # &lt;div data-complex='{\"user\": {\"name\": \"John\", \"age\": 30}, \"items\": [\"apple\", \"banana\"], \"active\": true}'&gt;&lt;/div&gt;\n\n    # Access and parse the JSON data\n    stored_data = json.loads(div[\"data-complex\"])\n    print(stored_data[\"user\"][\"name\"])  # John\n    print(stored_data[\"items\"][0])      # apple\n    print(stored_data[\"active\"])        # True\n</code></pre>"},{"location":"examples/ui/#comment-selectors","title":"Comment Selectors","text":"<p>Find elements that follow HTML comments:</p> <pre><code># HTML with comments\nhtml = \"\"\"\n&lt;div&gt;\n    &lt;!-- #submit-button --&gt;\n    &lt;button&gt;Submit&lt;/button&gt;\n\n    &lt;!-- .card --&gt;\n    &lt;div class=\"card\"&gt;Card 1&lt;/div&gt;\n    &lt;!-- .card --&gt;\n    &lt;div class=\"card\"&gt;Card 2&lt;/div&gt;\n&lt;/div&gt;\n\"\"\"\n\ncontainer = ui.raw(html)\n\n# Find first button after #submit-button comment\nbutton = container.comment_one(\"#submit-button\")\nprint(button)  # &lt;button&gt;Submit&lt;/button&gt;\n\n# Find all cards after .card comments\ncards = container.comment(\".card\")\nfor card in cards:\n    print(card)\n# &lt;div class=\"card\"&gt;Card 1&lt;/div&gt;\n# &lt;div class=\"card\"&gt;Card 2&lt;/div&gt;\n\n# No match returns None for comment_one\nno_match = container.comment_one(\"#nonexistent\")\nprint(no_match)  # None\n\n# No match returns empty list for comment\nno_matches = container.comment(\"#nonexistent\")\nprint(no_matches)  # []\n</code></pre>"}]}